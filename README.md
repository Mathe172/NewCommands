# NewCommands

##Contents
- [Description](#description)
	- [Installation](#installation)
	- [For end users](#for-end-users)
 	- [For developers](#for-developers)
- [MCP and Minecraft version](#mcp-and-minecraft-version)
- [Introduction to the syntax](#introduction-to-the-syntax)
- [Commands](#commands)
 	- [Command chaining](#command-chaining)
 	- [List of commands](#list-of-commands)
- [Selectors](#selectors)
 	- [Basic syntax](#basic-syntax)
 	- [List of selectors](#list-of-selectors)
- [Operators](#operators)
- [Labels](#labels)
- [Strings](#strings)
- [NBT](#nbt)
- [Examples](#examples)
 	- [Tab completion](#tab-completion)
- [Code model](#code-model)
	- [Registration examples](#registration-examples)

##Description
The primary intention of this Minecraft modification was to improve the performance and flexibility of the command system.  Although a lot of the commands are still missing, nearly all of the core functionality is here, of which we will list the most important ones (for examples see below):

###Installation
If you want to give it a try, just download the [installer-jar](https://github.com/Mathe172/NewCommands/blob/master/NewCommands_Installer_r1.1.jar?raw=true) and launch it. Note that an unmodified 1.8 version of the client/server needs to be installed for this to work. For the client installation, create a new profile and select the latest NewCommands-version under 'Use version'.

###For end users
* FULL backwards-compatibility (well almost... some things are interpreted that wouldn't have been before) - the syntax was just extended, not altered
* Commands in command blocks are asynchronously precompiled to greatly improve the performance of high frequency command block contraptions
* Everything can be used everywhere and more than once: Even inside selctors it is possible to write commands and the result can also be labeled for multiple usages later in the command
* Tab completion works everywhere and automatically: Everything the engine understands can be completed (and additionaly abbreviations (see below for examples)), no matter how complex the command is, and all this with minimal to no effort. The completion engine even understands NBT-Tags and helps completing them.

###For developers
**Important note**: Some files contain `OBFID`-variables generated by MCP. These files are mostly created by Mojang, we just modified some lines to tap into Minecraft. The other files are almost completely created by us. Also, the code for all commands that already exist in vanilla is mostly Mojang-code, we just ported it to our code-base.

* The parsing is handled by a central unit to which arbitrary ways of parsing the command can be added - from simple Integers to fully customized parsers
* Commands and selectors can easily be added using an intuitive chaining syntax, using predefined building blocks or completely new ones (as mentioned in the point above). It is also possible to register completely custom ones that would be too complex for this syntax, as it is the case with the Entity selector (since it requires dynamic parameter names for the `score_<name>` parameters)
* Tab completion is also processed asynchronously (except some thread-critical sections acquiring data from the main thread)
* Extremely modular: There is no difference between commands and other types (except that one is called by default) meaning they can be used everywhere interchangeably. It would for example be possible to parse the complete command (except the name) using a custom parser
* Everything is loaded at runtime: Command-, selector-, type- (...) registration is always possible, even at runtime

##MCP and Minecraft version
NewCommands is built on Minecraft 1.8 using MCP 9.10.

To compile, delete the unused files from the decompiled source: (see [here](https://github.com/Mathe172/NewCommands/blob/master/obsoleteClasses.dat))
* A line starting with `-` or `+` represents a folder that needs to be modified
* `+` means whitelist: Remove everything except the files listed
* `-` means blacklist: Remove only these files
AFTERWARDS copy both `Common/src/` and `Client/src/`/`Server/src/` into the source. 

**Note**: As of now, MCP contains two bugs preventing direct use of the reobfuscated code (described [here](http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-tools/1260561-toolkit-mod-coder-pack-mcp?comment=3271) and [here](http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-tools/1260561-toolkit-mod-coder-pack-mcp?comment=3272)) - direct execution using the `startclient.bat` files is still possible

To fix them the following steps are required:
* Delete the files `pd.class`, `pe.class` (only server), `pf.class` and `pg.class` form the `reobf`-folder
* Copy `net/minecraft/server/MinecraftServer$4.class` from `temp/client_reobf.jar` to `reobf/minecraft/net/minecraft/server/` 

##Introduction to the syntax

##Commands
A single command looks like this:
```
[<selector1> <selector2> ...] <command> [<argument1> ...]
```
The primary purpose of selectors preceding the command is to ensure the result is captured before anything is executed - consequently, they should be labeled for later access (further explanation below)

###Command chaining
Commands of the form above can be chained and grouped, allowing for multiple commands inside one command block:
```
<command 1> [,|;] <command2> ...
//or even
(<command1>; <command2>), ((<command3>, <command4>); ...)
```
The difference between `,` and `;` is quite simple: While the `,` prevents further execution (of the current scope) when encountering an error, the `;` ignores any errors of the (one) preceeding command

Parentheses are used to group commands: The whole construct can be used anywhere a single command could be. For chaining purposes, the whole group counts as single command (especially for the `,` and `;`)

**Note:** Most commands raise an error if nothing happened (e.g. no block/entity was changed, ...)

###List of commands
The following commands are completely unchanged (compared to current implementation)
* `/blockdata`
* `/deop`
* `/entitydata`
* `/gamemode`
* `/gamerule`
* `/kill`
* `/op`
* `/particle`
* `/say` (**Note**: Since everything after this command is interpreted as string, this command can't be chained with others)
* `/scoreboard`
* `/setblock`
* `/stats`
* `/stop`
* `/tp` (**Note**: `/tp <x> <y> <z>` does not work if `<x>` can be interpreted as entity name (i.e. is a simple integer constant; there is no way to distinguish it from `/tp <target-entity> <rx> <ry>`) use `/tp @s <x> <y> <z>` instead

These commands have changed: (Only changes are listed)
* `/clone`: optional `fast` flag (first parameter). If this flag is set, most safety mechanisms are deactivated, e.g. redstone may drop,... and block updates can be omitted sometimes. Should only be used for 'stable' structures made out of simple blocks. (As a benefit, it is faster)
* `/execute`: Position can be omitted (`/execute @e say ...` is allowed), it defaults to `~ ~ ~`. **Note**: If the preamble (selectors before command) is non-empty, parentheses should be used around the command (otherwise, the selectors might be interpreted as postions). Also, the `detect` part optionally accepts NBT-data to filter the block (while metadata can be omitted even with NBT-data, the should be specified when the NBT-data come from a selector)
* `/fill`: Same `fast`-flag as for `/clone`
* `/summon`: Optional `label <label-name>` parameter (first parameter): If specified, the resulting entity is available in the label `<label-name>` (see [labels-section](#labels) for more information)

The commands listed below are completely new:
* `/activate`:<br>
    **Syntax**: `/activate [<delay>] [<pos1>] [<pos2>]`<br>
    'Activates' all blocks specified (the positon of the sender, the block at `<pos1>` or the box specifed by `<pos1>` and `<pos2>`) after a delay of `<delay>` (defaulted to `1`) ticks (minimum is one). This 'activation' triggers command-blocks, grows crops, ...
* `/break`:<br>
    No arguments. Raises an error to leave `for`-loops and similar constructs
* `/explain`:<br>
	**Syntax**: `/explain [all|extended] [<position>]`<br>
	Gives further information about the errors that occured during parsing a command. If no position is specified, the last command of the player is analyzed (does **not** work on command-blocks or entities), otherwise the command stored in the command-block at position `<position>` is used.
	Without the `all`/`extended`-flag, only the error causing the command to fail is printed (with all its causes)
	With the flag specified, every error that occured during parsing is printed (even the ones that did not cause the command to fail), e.g. error caused by different possible interpretation of arguments. On hover, the output shows where the error occured.
* `/for`:<br>
    **Syntax**: `/for [safe] <label-name> <start> <end> [step <step>] <command>`<br>
    Executes the command once for each value of `<label-name>` specified by `<start>`,`<end>` (and optionally `<step>`). Before each execution, the value of the label `<label-name>` is set appropriately (For more information on labels, see the [labels-section](#labels)). If the `safe`-flag is set, execution is cancelled when an error occurs, otherwise ignored (except for the '`/break`-error', this always cancels the loop)
* `/if`:<br>
	**Syntax**: `/if <condition> <then-command> [else <else-command>]`<br>
	Self-explanatory. **Note**: `<then-command>` must be enclosed in parentheses if the else clause is present
* `/move`:<br>
	**Syntax**: `/move <entities> [<position>]`<br>
	Forces the entities to move to the specified position, resp. resets this behaviour (without the `<position>`-paramater). **Note**: For performance reasons, the path is rarely reevaluated.
* `/target`:<br>
	**Syntax**: `/target <entities> [<target-entity>]`<br>
	Forces the entities to attack the specified target entity (even themselves), resp. resets this behaviour (without the `<target-entity>`-parameter).
* `/try`:<br>
	**Syntax**: `/try <command> <command2>`<br>
	Executes `<command2>` if and only if `<command>` caused an error. **Note**: `<command>` must be enclosed in parentheses
* `/useitem`:<br>
	**Syntax**: `/useitem <entities>`<br>
	Lets the specified entities perform the swing/attack animation
    
##Selectors
While selectors are currently only used for selecting entities with specific properties, they can now be used to do a lot more: It's basically a way to input something in a different way than the default way: Instead of writing down the name of an entity/player, you can specify them using a selector. Now, you can also use things like the result of a calculation, the score of any player, ... (for a complete list, see below)
###Basic syntax
The syntax for all selectors is basically the same as it is now: `@<selector-name>`, optionally followed by a list of parameters to further specify what you want. If a parameter is specified more than once, only the last occurence counts. For some selectors, the parameter names for some of the parameters can be left away:
```
@e[<x>,<y>,<z>,<r>]
```
instead of
```
@e[x=<x>,y=<y>,z=<z>,r=<r>]
```

For all selectors, there is a parameter that can always be specified: `label=<label-name>`. If specified, the result of the selector is stored in the label with name `label-name`. For more information on labels, see the [labels-section](#labels).
While selectors can be used almost anywhere, there is one important exception: For most commands, there are keywords that further specify what the command should do (the `scoreboard` command for example has the keywords `players,objectives,...`). For technical reasons, these keywords can't be replaced by selectors.

###List of selectors
A complete list of selectors can be found in the table below. Parameter names in square bracked can be omitted and parameters in square brackets are optional. (note that the order of the unnamed parameters is important and can't be changed)

<table>
<thead>
<tr>
    <td align="center">Name</td>
    <td width="180em">Parameter</td>
    <td>Parameter-description</td>
    <td>Selector-description</td>
</tr>
</thead>
<tr>
    <td><code>@s</code></td>
    <td>-</td>
    <td>-</td>
    <td>A reference to whatever is executing the command</td>
</tr>
<tr>
    <td rowspan="5"><code>@p</code>
    <code>@a</code>
    <code>@r</code>
    <code>@e</code></td>
    <td>all parameters from vanilla</td>
    <td>see the wiki</td>
    <td rowspan="5">Selects entities that have specific properties (as it is already the c[ase in vanilla)</td>
</tr>
<tr>
    <td><code>[xyz=&lt;postion&gt;]</code></td>
    <td>Shorthand for <code>x</code>,<code>y</code>,<code>z</code>. If present, the others will be ignored
</tr>
<tr>
    <td><code>[dxyz=&lt;size&gt;]</code></td>
    <td>Shorthand for <code>dx</code>,<code>dy</code>,<code>dz</code>. If present, the others will be ignored. Only labels and selectors allowed (not things like <code>dxyz=2 2 2</code>)
</tr>
<tr>
    <td><code>[nbt=&lt;tag&gt;]</code></td>
    <td>Filters the entities using NBT-tags (like already present in <code>scoreboard</code> and some others
</tr>
<tr>
    <td><code>[team=[!]&lt;team(s)&gt;]</code><br/>
    <code>[name=[!]&lt;name(s)&gt;]</code><br/>
    <code>[type=[!]&lt;type(s)&gt;]</code></td>
    <td>Unlike in vanilla, these parameters accept lists (<code>(name1,name2,...)</code>) instead of single names ('either..., or ...'). If prefixed by a <code>!</code>, the list is inverted (as in 'neither ..., nor ...')</td>
</tr>
<tr>
    <td><code>@o</code></td>
    <td><code>&lt;objective-name&gt;</code></td>
    <td>The name of the objective to capture</td>
    <td>This is just for performance-reasons: Instead of searching the objective by name again and again, this allows you to label the result and use it elsewhere</td>
</tr>
<tr>
    <td rowspan="2"><code>@sc</code></td>
    <td><code>[o=]&lt;objective-name&gt;</code>
    <td>The objective of interest (by default the name)</td>
    <td rowspan="2">Used to query the score of an entity/variable from a scoreboard objective</td>
</tr>
<tr>
    <td><code>[[t=]&lt;entity/variable&gt;]</code></td>
    <td>The entity/variable to read from. If omitted, the executor of the command is taken</td>
</tr>
<tr>
    <td rowspan="2"><code>@n</code></td>
    <td><code>&lt;coords|entity|tag|string&gt;</code></td>
    <td>Any source of nbt-data: Coordinates:the block is taken, entity: clear, tag: clear, string: the string is interpreted at runtime (can be used to store nbt inside a name/book/...)</td>
    <td rowspan="2">Reads nbt-data from the given source. Can also be used to read out parts of the tag</td>
</tr>
<tr>
    <td><code>[&lt;path&gt;]</code></td>
    <td>The path inside the tag to read from (separated by <code>.</code>). For compounds, this is the key name. For lists, this is the index</td>
</tr>
<tr>
    <td><code>@t</code></td>
    <td><code>[cmd=]&lt;command&gt;</code></td>
    <td>The command to be benchmarked</td>
    <td>Measures the execution time of a given command and returns the result in microseconds</td>
</tr>
<tr>
    <td><code>@b</code></td>
    <td><code>&lt;coordinates&gt;</code></td>
    <td>The position of the block</td>
    <td>Used to query the block-state at a given position (the state contains type and metadata, but no tile-entities)</td>
</tr>
<tr>
    <td><code>@c</code></td>
    <td><code>&lt;operator&gt; ...</code></td>
    <td>see <a href="#operators">Operators-section</a></td>
    <td>Used to perform calculations. For a complete list of available operators, see <a href="#operators">below</a></td>
</tr>
</table>

##Operators
Due to technical limitations, the operators use prefix notation (this means that the operator is before its operands: `+ 1 2` instead of `1 + 2`). 

**Important note**: Since operator names can contain anything (except a whitespace), there has to be a whitespace after every operator. This is especially true for the constants defined below (even if they are the last thing in the selector)

There is a wide range of operators available:

|Operator|Description|
|--------|-----------|
|`+`,`-`,`*`,`/`| The standard binary addition/... operators|
|`-0`| The unary sign inversion operator (shorthand for `- 0 ...`)
|`%`/`mod`| The modulo operator|
|`<`,`<=`,`>`,`>=`,`!=`,`==`| Comparision operators |
|`!`/`not`,`&`/`and`,`&&`,`|`/`or`,`||`| Logical operators. The `&&`  and `||` operator are the short-circuit versions of `&` and `|`: They do **not** evaluate the second argument if unnecessary|
|`sq`,`sqrt`| The square and squareroot operator|
|`rnd`| A random number between `0` and `1` (**Note**: Since this is a "constant", a space is always required afterwards)|
|`rndI`| Returns a random integer between the two boundaries specified (inclusive)|
|`sin`,`cos`,`exp`,`ln`,`^`/`pow`| The standard analytic functions. `^` is the power operator: `^ 2 3` `=8`. To stay with the rest of minecraft, `sin` and `cos` use degrees (not radians)|
|`pi`,`e_`| The mathematical constants|
|`+v`,`-v`| Vector addition and subtraction|
|`*v`,`/v`| Scalar multiplication and division. The scalar is the first argument|
|`.`| The vector dot-product|
|`v0`| Normalizes the vector|
|`abs`| Length of the vector|
|`cv`| `x` and `z` are centered to the block-center, `y` is floored (`1.35 0.7 2.5`->`1.5 0 2.5`)|
|`xv`,`yv`,`zv`| Reads the specified component from a vector|
|`ex`,`ey`,`ez`| The vectors of unitiy|
|`rxv`,`ryv`| The angles to describe the direction of the vector. The convention is the same as for the entity-selector (see the `rx`,`ry` parameters|
|`pos`,`x`,`y`,`z`| The position / components of the position of an entity|
|`rx`,`ry`| The angles describing the facing direction of an entity (like above, see entity-selector)|
|`fv`| The normalized vector pointing in the direction the entity is facing|
|`rd`| The entity ridden by another entity|
|`slot`| The selected slot of a player (from `0` to `8`)|
|`items`| First operand: NBT-List contaning items. Second operand: An integer-list. This operator returns an NBT-List containing the items specified by the index-list in the correct order (The `slot:`-tag is used to find the items). Can be used to 'convert' the player equipment to entity-equipment|
|`isAir`| Returns if the given block-state (**not** position) is air|
|`meta`| Returns the metadata of a given block-state (**not** positon)|
|`i`,`s`,`e`,`v`| Converts the argument into integer/string/entity/vector|

##Labels
Labels are a way of referencing results from earlier in the command (every selector can be labeled, and some commands provide ways to define labels). To reference a label, use `$<label-name>` anywhere where a selector would be allowed. Like everything else, labels have a type associated to them. Normally, the type is infered by the selector/command where the label is defined. If, for reasons as the ones below, you want to choose a different (but compatible) type, you can do so by specifying the type as `<label-name>:<type>`.
Normally, a label can only be defined once. To use the same label multiple times, there are two possibilities:
* Define the label with `*<label-name>`: In this case, label-name is just 'shared', the original place and this one both write their results into the same label (the `*` just signifies that you know that the label is already in use) Note that the type has to be exactly the same for the existing label and this declaration.
* Define the label with `^<label-name>`: Similar to above. However, it is possible that the value that is to be set to the label is converted appropriately to match the type of the label.

**Note**: Sometimes, the labels are not registered exactly where the label-name is in the command: The `summon`-commmand for example registers its label at its end (for obvious reasons). This means that the following is valid (note the places where the label is (re)defined)
```
summon label ^e Pig @c[pos @e[c=1,label=e]], say $e
```
For selectors, the registration happens right after the closing brackets, for the `for`-command it happens just before the command to be executed.

##Strings
In most places where a string is required, you can place a composite string. The syntax is as follows:
```
"...\@<selector>...\$<label>..."
```

That is, the string is enclosed inside `"`. Inside the quotation marks, some things have to be escaped: (note however, that recursive selectors must not be escaped beyond the first `@`)
* `"` &#8594; `\"`
* `@<selector>` &#8594; `\@<selector>`
* `$<label>` &#8594; `\$<label>`

You may want to insert a label, but omit the whitespace that is required after it, (`$l -text` would be evaluated to `label text` assuming the label `$l` contains `label`; `$l-text` would fail since no label called `l-text` exists) you can do so by using `\!` as 'zero-width' character: `$l\!-text` will be evaluated to `label-text` (again assuming `$l` holds `label`)

##NBT
The syntax to input NBT is nearly the same as it is in vanilla. For backwards-compatibility reasons, selectors and labels have to be escaped when they should be evaluated: `{CustomName:\$name}` instead of `{CustomName:$name}`. If you want to specify the type of a selector/label, you can do so by using the same literals as for numbers: `b`,`s`,`i`,`l`,`f`,`d`. These literal also work after a string enclosed in quotation marks (so you can 'build' your numbers/values from multiple selectors and labels)

##Examples
```
for x 1 5 summon Blaze ~ ~$x ~ {CustomName:"Blaze #\$x"}
```
Summons 5 Blazes on top of each other, named 'Blaze #1', ... (note that inside NBT-Tags, selectors and labels have to be escaped using `\` to improve backwards-compatibility)

```
activate, @p[label=p] @c[cos ry $p,label=fy] @c[-0 * $fy sin rx $p,label=dx] @c[* $fy cos rx $p,label=dz] @c[-0 sin ry $p,label=dy] execute $p (execute @e[type=Snowball,c=1,r=5] kill @s, for safe n 5 500 summon PrimedTnt ~@c[* $n $dx] ~@c[* $n $dy] ~@c[* $n $dz])
```
This command summons a ray of TNT in the direction the player is looking at when they throw a snowball. Without going in full detail, these are the main steps performed by the command:
* `activate` triggers the command-block in the next tick (this replaces the setblock-clock)
* calculate some things used to summon the ray in the correct direction
* `execute` on the player and the on the nearest snowball
* when a snowball is found, `kill` it and `summon` the ray using a `for`-loop. The `safe`-flag tells the `for`-command to stop when the first `summon` fails (we reached the top/bottom of the world

Note: To start the command, power the command-block once

```
activate, execute @p (tp @e[name=Mirror] ~ ~ ~ @c[-0 rx @s] @c[ry @s], @c[items @n[@s,Inventory] (@c[slot @s],100,101,102,103),label=i] entitydata @e[name=Mirror] {Equipment:\$i})
```

Lets every entity named `Mirror` mirror your head rotation and equipment (As can be seen, the currently selected slot as well as your armor are copied)

###Tab completion
As mentioned, tab completion understands abbreviations: (`|` is the cursor)
```
/scr| -> /scoreboard|
/scr|brd -> /scoreboard|
/say @t| -> /say @t[|]
/summon PrimedTnt ~ ~ ~ {Custom|} -> /summon PrimentTnt ~ ~ ~ {CustomName:|} AND ... {CustomNameVisible:|}
```

As can be seen, even the cursor position is set appropriately after choosing a completion (also, neccessary characters like `:` are added). To iterate through the possible completions, `TAB` iterates forward, `SHIFT+TAB` backwards and holding down `CTRL` always starts a new completion (and finishes the current one by choosing the current item). Note that the first character (or nothing at all) has to be present for a completion to be proposed. So `/crbrd|` will not be completed (but `/|crbrd` will be, since nothing at all is before the cursor)


##Code model
There are only a few basic structures:
* `CommandArg`: The basic element that represents the result of one unit, most importantly they are passed to commands/selctors instead of plain Strings (it gets the `ICommandSender`for evaluation)
* `TypeID`: Represents a type like Integer, String or EntityList, knows and handles the conversions of `CommandArg's` to `CommandArg's` returning data of other types (again described by a `TypeID`)
* `ArgWrapper`: Combines the `CommandArg` and `TypeID` into one unit and allows for type-safe conversion
* `IDataType`, `IParse`, `IComplete`, ...: Interfaces and classes that describe the capabilities of a parsing unit and handle necessary wrappers for completion
* `CommandDescriptor`: As the name suggests, this describes a command. It knows a list of `IDataType's` (in some way, a `IDataType` is a `TypeID` with an associated parser and completion) as arguments and a list of subcommands (again `CommandDescriptor's`) identified by keywords. Also provides a construct-method that is called by the central parser once all the necessary data are acquired and provides usage description and an `IPermisson` instance to handle execution permissons
* `SelectorDescriptor`: Similary to the `CommandDescriptor` knows a list of parameters (optionally identified by a name) that it can handle (as in the current syntax, unnamed parameters can be written before other parameters as shorthand notation) with the associated `IDataType's`.
* `Getter`: A reference to the result of a `CommandArg` that is already evaluated. This mechanism is used for selectors: Selector arguments are preevaluated and passed as `Getter's` to ensure that the evaluation order matches their order in the command (these evaluations might have side-effects, e.g. label overrides,...)

**Note**: For commands (and operators), it is very important that the arguments are evaluated in the correct order. Also, parameter validations should only be done after everything is evaluated. This ensures that it is always clear what gets executed in which order. (For selectors, this is automatically done since it would be impossible otherwise, see above)

###Registration examples
The following example registers the `for`-command and handles its construction. The necessary `IDataType's` are part of the default-set.
```java
public final class Commands extends RegistrationHelper
{
	...
	
	public static final void init()
	{
		...
	
		register(command(CommandFor.ignoreErrorConstructable, IPermission.level2, usage("commands.for.usage"), "for")
			.optional(
				command(CommandFor.constructable, "safe"))
			.then(TypeLabelDeclaration.intNonInstant)
			.then(ParserInt.parser)
			.then(ParserInt.parser)
			.optional(
				command("step")
					.then(ParserInt.parser))
			.then(ProvideLastLabel.parser) //This makes the label visible. (for obvious reasons, the label should not be accessible for the limits of the loop)
			.then(TypeCommand.parserSingleCmd));
		
		...
	}
	
	...
	
// ###############################################################################
// ############################### CommandFor.java ###############################
// ###############################################################################
	
public class CommandFor extends CommandArg<Integer>
{
	public static final CommandConstructable constructable = new CommandConstructable()
	{
		@Override
		public CommandFor construct(final CParserData data)
		{
			return new CommandFor(data, false);
		}
	};
	
	public static final CommandConstructable ignoreErrorConstructable = new CommandConstructable()
	{
		@Override
		public CommandFor construct(final CParserData data)
		{
			return new CommandFor(data, true);
		}
	};
	
	private final Setter<Integer> label;
	private final CommandArg<Integer> start, end, step;
	private final CommandArg<Integer> command;
	private final boolean ignoreErrors;
	
	public CommandFor(final CParserData data, final boolean ignoreErrors)
	{
		this.label = data.getLabel(TypeIDs.Integer);
		this.start = data.get(TypeIDs.Integer);
		this.end = data.get(TypeIDs.Integer);
		this.step = data.path.size() == (ignoreErrors ? 0 : 1) ? null : data.get(TypeIDs.Integer);
		this.command = data.get(TypeIDs.Integer);
		this.ignoreErrors = ignoreErrors;
	}
	
	...
}

```

This example registers the score-selector:
```java
public final class Selectors extends RegistrationHelper
{
	...

	public static final void init()
	{
		...
		
		register("o",
			selector(
				TypeScoreObjective.type,
				PrimitiveWrapper.constructable,
				IPermission.level2,
				TypeIDs.ScoreObjective));
		
		register("sc", selector(IPermission.level2, TypeIDs.Integer)
			.then("o", TypeScoreObjective.type)
			.then("t", Types.scoreHolder)
			.construct(SelectorScore.constructable));
		
		...
	}
	
	...
}

// ###############################################################################
// ############################## SelectorScore.java #############################
// ###############################################################################

public class SelectorScore extends CommandArg<Integer>
{
	public static final SelectorConstructable constructable = new SelectorConstructable()
	{
		@Override
		public ArgWrapper<?> construct(final DefaultParserData parserData) throws SyntaxErrorException
		{
			return TypeIDs.Integer.wrap(
				new SelectorScore(
					getRequiredParam(TypeIDs.ScoreObjective, 0, "o", parserData),
					getParam(TypeIDs.UUID, 1, "t", parserData)));
		}
	};
	
	private final Getter<ScoreObjective> objective;
	private final Getter<String> target;
	
	public SelectorScore(final Getter<ScoreObjective> objective, final Getter<String> target)
	{
		this.objective = objective;
		this.target = target;
	}
	
	@Override
	public Integer eval(final ICommandSender sender) throws CommandException
	{
		return MinecraftServer
			.getServer()
			.worldServerForDimension(0)
			.getScoreboard()
			.getValueFromObjective(
				this.target == null
					? ParsingUtilities.getEntityIdentifier(sender.getCommandSenderEntity())
					: this.target.get(),
				this.objective.get())
			.getScorePoints();
	}
}
```
